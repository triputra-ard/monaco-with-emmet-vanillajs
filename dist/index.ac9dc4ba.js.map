{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-e4c91a672d639e35.js","src/index.mjs","node_modules/@monaco-editor/loader/lib/es/index.js","node_modules/@monaco-editor/loader/lib/es/loader/index.js","node_modules/@monaco-editor/loader/lib/es/_virtual/_rollupPluginBabelHelpers.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","node_modules/state-local/lib/es/state-local.js","node_modules/@monaco-editor/loader/lib/es/config/index.js","node_modules/@monaco-editor/loader/lib/es/validators/index.js","node_modules/@monaco-editor/loader/lib/es/utils/curry.js","node_modules/@monaco-editor/loader/lib/es/utils/isObject.js","node_modules/@monaco-editor/loader/lib/es/utils/compose.js","node_modules/@monaco-editor/loader/lib/es/utils/deepMerge.js","node_modules/@monaco-editor/loader/lib/es/utils/makeCancelable.js","node_modules/emmet-monaco-es/dist/emmet-monaco.esm.js"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";module.bundle.HMR_BUNDLE_ID = \"16df5292ac9dc4ba\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */, assetsToDispose /*: Array<[ParcelRequire, string]> */, assetsToAccept /*: Array<[ParcelRequire, string]> */;\n\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || location.port;\n}\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';\n  var ws;\n  try {\n    ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n  } catch (err) {\n    if (err.message) {\n      console.error(err.message);\n    }\n    ws = {};\n  }\n\n  // Web extension context\n  var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n\n  // $FlowFixMe\n  ws.onmessage = async function (event /*: {data: string, ...} */) {\n    checkedAssets = {} /*: {|[string]: boolean|} */;\n    assetsToAccept = [];\n    assetsToDispose = [];\n    var data /*: HMRMessage */ = JSON.parse(event.data);\n    if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);\n\n      // Handle HMR Update\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n      if (handled) {\n        console.clear();\n\n        // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n        await hmrApplyUpdates(assets);\n\n        // Dispose all old assets.\n        let processedAssets = {} /*: {|[string]: boolean|} */;\n        for (let i = 0; i < assetsToDispose.length; i++) {\n          let id = assetsToDispose[i][1];\n          if (!processedAssets[id]) {\n            hmrDispose(assetsToDispose[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n\n        // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n        processedAssets = {};\n        for (let i = 0; i < assetsToAccept.length; i++) {\n          let id = assetsToAccept[i][1];\n          if (!processedAssets[id]) {\n            hmrAccept(assetsToAccept[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n      } else fullReload();\n    }\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error(' [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html);\n        // $FlowFixMe\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n  ws.onerror = function (e) {\n    if (e.message) {\n      console.error(e.message);\n    }\n  };\n  ws.onclose = function () {\n    console.warn('[parcel]  Connection to the HMR server was lost');\n  };\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel]  Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n           ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div> ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div> <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension fix\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n            extCtx.runtime.reload();\n            return;\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    } else if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return true;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToDispose.push([bundle, id]);\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      var assetsToAlsoAccept = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (assetsToAlsoAccept && assetsToAccept.length) {\n        assetsToAlsoAccept.forEach(function (a) {\n          hmrDispose(a[0], a[1]);\n        });\n\n        // $FlowFixMe[method-unbinding]\n        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);\n      }\n    });\n  }\n}","import \"./styles.css\";\nimport loader from \"@monaco-editor/loader\";\nimport { emmetHTML } from \"emmet-monaco-es\";\n\n// Write Javascript code!\n// const appDiv = document.getElementById('app');\n// Initial data\nconst HTML_CODE = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n   <meta charset=\"UTF-8\">\n   <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   <title>Document</title>\n</head>\n<body>\n   <div class=\"p-4\">\n   <div class=\"alert alert-warning\" role=\"alert\">\n      Bootstrap 5 CSS injected\n   </div>\n\n   <div class=\"card\">\n      <div class=\"card-body\">\n         <h5 class=\"card-title\">Special title treatment</h5>\n         <p class=\"card-text\">With supporting text below as a natural lead-in to additional content.</p>\n         <a href=\"https://triputra-ard.vercel.app\" class=\"btn btn-primary\">Go somewhere</a>\n      </div>\n   </div>\n</div>\n</body>\n</html>\n`;\nconst CSS_LINKS = [\n  `https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css`,\n];\n\n// Elements\nconst editorCode = document.getElementById(\"editorCode\");\nconst editorPreview =\n  document.getElementById(\"editorPreview\").contentWindow.document;\nconst editorCopyButton = document.getElementById(\"editorCopyClipboard\");\nconst editorFormatter = document.getElementById(\"formatter\");\n\n// <iframe> inject CSS\nCSS_LINKS.forEach((linkURL) => {\n  const link = document.createElement(\"link\");\n  link.href = linkURL;\n  link.rel = \"stylesheet\";\n  editorPreview.head.appendChild(link);\n});\n\n// Monaco loader\n// loader.config({\n//   paths: { vs: './node_modules/monaco-editor/min/vs' },\n// });\n\nloader.init().then((monaco) => {\n  createEditor(editorCode);\n  emmetHTML();\n});\n\nfunction createEditor(editorContainer) {\n  let editor = monaco.editor.create(editorContainer, {\n    value: HTML_CODE,\n    language: \"html\",\n    minimap: { enabled: true },\n    autoIndent: true,\n    formatOnPaste: true,\n    formatOnType: true,\n    automaticLayout: true,\n    contextmenu: false,\n    fontSize: 12,\n    theme: \"vs-light\",\n    scrollbar: {\n      useShadows: false,\n      vertical: \"visible\",\n      horizontal: \"visible\",\n      horizontalScrollbarSize: 12,\n      verticalScrollbarSize: 12,\n    },\n  });\n\n  //   emmetHTML(editor);\n  editorPreview.body.innerHTML = HTML_CODE;\n\n  editor.onDidChangeModelContent(() => {\n    editorPreview.body.innerHTML = editor.getValue();\n  });\n\n  setTimeout(() => {\n    editor.getAction(\"editor.action.formatDocument\").run();\n    editor.trigger(\"anyString\", \"editor.action.formatDocument\");\n  }, 1000);\n\n  editorFormatter.onclick = () => {\n    editor.getAction(\"editor.action.formatDocument\").run();\n  };\n  editorCopyButton.onclick = () => {\n    console.log(editor.getValue());\n    copyToClipboard(editor.getValue());\n    const editorCopyButtonText = editorCopyButton.innerHTML;\n    editorCopyButton.innerHTML = \"Copied!\";\n    editorCopyButton.disabled = true;\n    setTimeout(() => {\n      editorCopyButton.disabled = false;\n      editorCopyButton.innerHTML = editorCopyButtonText;\n    }, 500);\n  };\n}\n\nfunction copyToClipboard(str) {\n  const el = document.createElement(\"textarea\");\n  el.value = str;\n  document.body.appendChild(el);\n  el.select();\n  document.execCommand(\"copy\");\n  document.body.removeChild(el);\n}\n","import loader from './loader/index.js';\nexport { default } from './loader/index.js';\n","import { slicedToArray as _slicedToArray, objectWithoutProperties as _objectWithoutProperties } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport state from 'state-local';\nimport config$1 from '../config/index.js';\nimport validators from '../validators/index.js';\nimport compose from '../utils/compose.js';\nimport merge from '../utils/deepMerge.js';\nimport makeCancelable from '../utils/makeCancelable.js';\n\n/** the local state of the module */\n\nvar _state$create = state.create({\n  config: config$1,\n  isInitialized: false,\n  resolve: null,\n  reject: null,\n  monaco: null\n}),\n    _state$create2 = _slicedToArray(_state$create, 2),\n    getState = _state$create2[0],\n    setState = _state$create2[1];\n/**\n * set the loader configuration\n * @param {Object} config - the configuration object\n */\n\n\nfunction config(globalConfig) {\n  var _validators$config = validators.config(globalConfig),\n      monaco = _validators$config.monaco,\n      config = _objectWithoutProperties(_validators$config, [\"monaco\"]);\n\n  setState(function (state) {\n    return {\n      config: merge(state.config, config),\n      monaco: monaco\n    };\n  });\n}\n/**\n * handles the initialization of the monaco-editor\n * @return {Promise} - returns an instance of monaco (with a cancelable promise)\n */\n\n\nfunction init() {\n  var state = getState(function (_ref) {\n    var monaco = _ref.monaco,\n        isInitialized = _ref.isInitialized,\n        resolve = _ref.resolve;\n    return {\n      monaco: monaco,\n      isInitialized: isInitialized,\n      resolve: resolve\n    };\n  });\n\n  if (!state.isInitialized) {\n    setState({\n      isInitialized: true\n    });\n\n    if (state.monaco) {\n      state.resolve(state.monaco);\n      return makeCancelable(wrapperPromise);\n    }\n\n    if (window.monaco && window.monaco.editor) {\n      storeMonacoInstance(window.monaco);\n      state.resolve(window.monaco);\n      return makeCancelable(wrapperPromise);\n    }\n\n    compose(injectScripts, getMonacoLoaderScript)(configureLoader);\n  }\n\n  return makeCancelable(wrapperPromise);\n}\n/**\n * injects provided scripts into the document.body\n * @param {Object} script - an HTML script element\n * @return {Object} - the injected HTML script element\n */\n\n\nfunction injectScripts(script) {\n  return document.body.appendChild(script);\n}\n/**\n * creates an HTML script element with/without provided src\n * @param {string} [src] - the source path of the script\n * @return {Object} - the created HTML script element\n */\n\n\nfunction createScript(src) {\n  var script = document.createElement('script');\n  return src && (script.src = src), script;\n}\n/**\n * creates an HTML script element with the monaco loader src\n * @return {Object} - the created HTML script element\n */\n\n\nfunction getMonacoLoaderScript(configureLoader) {\n  var state = getState(function (_ref2) {\n    var config = _ref2.config,\n        reject = _ref2.reject;\n    return {\n      config: config,\n      reject: reject\n    };\n  });\n  var loaderScript = createScript(\"\".concat(state.config.paths.vs, \"/loader.js\"));\n\n  loaderScript.onload = function () {\n    return configureLoader();\n  };\n\n  loaderScript.onerror = state.reject;\n  return loaderScript;\n}\n/**\n * configures the monaco loader\n */\n\n\nfunction configureLoader() {\n  var state = getState(function (_ref3) {\n    var config = _ref3.config,\n        resolve = _ref3.resolve,\n        reject = _ref3.reject;\n    return {\n      config: config,\n      resolve: resolve,\n      reject: reject\n    };\n  });\n  var require = window.require;\n\n  require.config(state.config);\n\n  require(['vs/editor/editor.main'], function (monaco) {\n    storeMonacoInstance(monaco);\n    state.resolve(monaco);\n  }, function (error) {\n    state.reject(error);\n  });\n}\n/**\n * store monaco instance in local state\n */\n\n\nfunction storeMonacoInstance(monaco) {\n  if (!getState().monaco) {\n    setState({\n      monaco: monaco\n    });\n  }\n}\n/**\n * internal helper function\n * extracts stored monaco instance\n * @return {Object|null} - the monaco instance\n */\n\n\nfunction __getMonacoInstance() {\n  return getState(function (_ref4) {\n    var monaco = _ref4.monaco;\n    return monaco;\n  });\n}\n\nvar wrapperPromise = new Promise(function (resolve, reject) {\n  return setState({\n    resolve: resolve,\n    reject: reject\n  });\n});\nvar loader = {\n  config: config,\n  init: init,\n  __getMonacoInstance: __getMonacoInstance\n};\n\nexport default loader;\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nexport { _arrayLikeToArray as arrayLikeToArray, _arrayWithHoles as arrayWithHoles, _defineProperty as defineProperty, _iterableToArrayLimit as iterableToArrayLimit, _nonIterableRest as nonIterableRest, _objectSpread2 as objectSpread2, _objectWithoutProperties as objectWithoutProperties, _objectWithoutPropertiesLoose as objectWithoutPropertiesLoose, _slicedToArray as slicedToArray, _unsupportedIterableToArray as unsupportedIterableToArray };\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction compose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function (x) {\n    return fns.reduceRight(function (y, f) {\n      return f(y);\n    }, x);\n  };\n}\n\nfunction curry(fn) {\n  return function curried() {\n    var _this = this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return args.length >= fn.length ? fn.apply(this, args) : function () {\n      for (var _len3 = arguments.length, nextArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        nextArgs[_key3] = arguments[_key3];\n      }\n\n      return curried.apply(_this, [].concat(args, nextArgs));\n    };\n  };\n}\n\nfunction isObject(value) {\n  return {}.toString.call(value).includes('Object');\n}\n\nfunction isEmpty(obj) {\n  return !Object.keys(obj).length;\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction hasOwnProperty(object, property) {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\n\nfunction validateChanges(initial, changes) {\n  if (!isObject(changes)) errorHandler('changeType');\n  if (Object.keys(changes).some(function (field) {\n    return !hasOwnProperty(initial, field);\n  })) errorHandler('changeField');\n  return changes;\n}\n\nfunction validateSelector(selector) {\n  if (!isFunction(selector)) errorHandler('selectorType');\n}\n\nfunction validateHandler(handler) {\n  if (!(isFunction(handler) || isObject(handler))) errorHandler('handlerType');\n  if (isObject(handler) && Object.values(handler).some(function (_handler) {\n    return !isFunction(_handler);\n  })) errorHandler('handlersType');\n}\n\nfunction validateInitial(initial) {\n  if (!initial) errorHandler('initialIsRequired');\n  if (!isObject(initial)) errorHandler('initialType');\n  if (isEmpty(initial)) errorHandler('initialContent');\n}\n\nfunction throwError(errorMessages, type) {\n  throw new Error(errorMessages[type] || errorMessages[\"default\"]);\n}\n\nvar errorMessages = {\n  initialIsRequired: 'initial state is required',\n  initialType: 'initial state should be an object',\n  initialContent: 'initial state shouldn\\'t be an empty object',\n  handlerType: 'handler should be an object or a function',\n  handlersType: 'all handlers should be a functions',\n  selectorType: 'selector should be a function',\n  changeType: 'provided value of changes should be an object',\n  changeField: 'it seams you want to change a field in the state which is not specified in the \"initial\" state',\n  \"default\": 'an unknown error accured in `state-local` package'\n};\nvar errorHandler = curry(throwError)(errorMessages);\nvar validators = {\n  changes: validateChanges,\n  selector: validateSelector,\n  handler: validateHandler,\n  initial: validateInitial\n};\n\nfunction create(initial) {\n  var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validators.initial(initial);\n  validators.handler(handler);\n  var state = {\n    current: initial\n  };\n  var didUpdate = curry(didStateUpdate)(state, handler);\n  var update = curry(updateState)(state);\n  var validate = curry(validators.changes)(initial);\n  var getChanges = curry(extractChanges)(state);\n\n  function getState() {\n    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (state) {\n      return state;\n    };\n    validators.selector(selector);\n    return selector(state.current);\n  }\n\n  function setState(causedChanges) {\n    compose(didUpdate, update, validate, getChanges)(causedChanges);\n  }\n\n  return [getState, setState];\n}\n\nfunction extractChanges(state, causedChanges) {\n  return isFunction(causedChanges) ? causedChanges(state.current) : causedChanges;\n}\n\nfunction updateState(state, changes) {\n  state.current = _objectSpread2(_objectSpread2({}, state.current), changes);\n  return changes;\n}\n\nfunction didStateUpdate(state, handler, changes) {\n  isFunction(handler) ? handler(state.current) : Object.keys(changes).forEach(function (field) {\n    var _handler$field;\n\n    return (_handler$field = handler[field]) === null || _handler$field === void 0 ? void 0 : _handler$field.call(handler, state.current[field]);\n  });\n  return changes;\n}\n\nvar index = {\n  create: create\n};\n\nexport default index;\n","var config = {\n  paths: {\n    vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs'\n  }\n};\n\nexport default config;\n","import curry from '../utils/curry.js';\nimport isObject from '../utils/isObject.js';\n\n/**\n * validates the configuration object and informs about deprecation\n * @param {Object} config - the configuration object \n * @return {Object} config - the validated configuration object\n */\n\nfunction validateConfig(config) {\n  if (!config) errorHandler('configIsRequired');\n  if (!isObject(config)) errorHandler('configType');\n\n  if (config.urls) {\n    informAboutDeprecation();\n    return {\n      paths: {\n        vs: config.urls.monacoBase\n      }\n    };\n  }\n\n  return config;\n}\n/**\n * logs deprecation message\n */\n\n\nfunction informAboutDeprecation() {\n  console.warn(errorMessages.deprecation);\n}\n\nfunction throwError(errorMessages, type) {\n  throw new Error(errorMessages[type] || errorMessages[\"default\"]);\n}\n\nvar errorMessages = {\n  configIsRequired: 'the configuration object is required',\n  configType: 'the configuration object should be an object',\n  \"default\": 'an unknown error accured in `@monaco-editor/loader` package',\n  deprecation: \"Deprecation warning!\\n    You are using deprecated way of configuration.\\n\\n    Instead of using\\n      monaco.config({ urls: { monacoBase: '...' } })\\n    use\\n      monaco.config({ paths: { vs: '...' } })\\n\\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\\n  \"\n};\nvar errorHandler = curry(throwError)(errorMessages);\nvar validators = {\n  config: validateConfig\n};\n\nexport default validators;\nexport { errorHandler, errorMessages };\n","function curry(fn) {\n  return function curried() {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return args.length >= fn.length ? fn.apply(this, args) : function () {\n      for (var _len2 = arguments.length, nextArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        nextArgs[_key2] = arguments[_key2];\n      }\n\n      return curried.apply(_this, [].concat(args, nextArgs));\n    };\n  };\n}\n\nexport default curry;\n","function isObject(value) {\n  return {}.toString.call(value).includes('Object');\n}\n\nexport default isObject;\n","var compose = function compose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function (x) {\n    return fns.reduceRight(function (y, f) {\n      return f(y);\n    }, x);\n  };\n};\n\nexport default compose;\n","import { objectSpread2 as _objectSpread2 } from '../_virtual/_rollupPluginBabelHelpers.js';\n\nfunction merge(target, source) {\n  Object.keys(source).forEach(function (key) {\n    if (source[key] instanceof Object) {\n      if (target[key]) {\n        Object.assign(source[key], merge(target[key], source[key]));\n      }\n    }\n  });\n  return _objectSpread2(_objectSpread2({}, target), source);\n}\n\nexport default merge;\n","// The source (has been changed) is https://github.com/facebook/react/issues/5465#issuecomment-157888325\nvar CANCELATION_MESSAGE = {\n  type: 'cancelation',\n  msg: 'operation is manually canceled'\n};\n\nfunction makeCancelable(promise) {\n  var hasCanceled_ = false;\n  var wrappedPromise = new Promise(function (resolve, reject) {\n    promise.then(function (val) {\n      return hasCanceled_ ? reject(CANCELATION_MESSAGE) : resolve(val);\n    });\n    promise[\"catch\"](reject);\n  });\n  return wrappedPromise.cancel = function () {\n    return hasCanceled_ = true;\n  }, wrappedPromise;\n}\n\nexport default makeCancelable;\nexport { CANCELATION_MESSAGE };\n","/**\n * Check if given code is a number\n */\nfunction isNumber$1(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha$1(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber$1(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha$1(code);\n}\n/**\n * Check for Umlauts i.e. , , , ,  and \n */\nfunction isUmlaut(code) {\n    return code === 196\n        || code == 214\n        || code === 220\n        || code === 228\n        || code === 246\n        || code === 252;\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace$3(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace$3(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote$2(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nfunction tokenScanner$1(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$3(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable$1(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$2(scanner, test) {\n    const token = peek$3(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error$1(scanner, message, token = peek$3(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner$1(abbr);\n    const result = statements(scanner, options);\n    if (readable$1(scanner)) {\n        throw error$1(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable$1(scanner)) {\n        if (node = element$2(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume$2(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume$2(scanner, isSiblingOperator$1)) {\n                continue;\n            }\n            else if (consume$2(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume$2(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume$2(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket$2(token, 'group', false)) {\n            result.repeat = repeater$1(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element$2(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable$1(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume$2(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume$2(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume$2(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume$2(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable$1(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume$2(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume$2(scanner, isWhiteSpace$2)) {\n                throw error$1(scanner, `Unexpected \"${peek$3(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator$1(peek$3(scanner), type)) {\n        scanner.pos++;\n        // Consume multiple operators\n        let count = 1;\n        while (isOperator$1(peek$3(scanner), type)) {\n            scanner.pos++;\n            count++;\n        }\n        const attr = {\n            name: [createLiteral$1(type)]\n        };\n        if (count > 1) {\n            attr.multiple = true;\n        }\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal$1$1(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: its a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal$1$1(scanner, true)) {\n        const name = slice(scanner);\n        let value;\n        if (consume$2(scanner, isEquals)) {\n            if (quoted(scanner) || literal$1$1(scanner, true)) {\n                value = slice(scanner);\n            }\n        }\n        return { name, value };\n    }\n}\nfunction repeater$1(scanner) {\n    return isRepeater(peek$3(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek$3(scanner);\n    if (isQuote$1(quote)) {\n        scanner.pos++;\n        while (readable$1(scanner)) {\n            if (isQuote$1(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error$1(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal$1$1(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable$1(scanner)) {\n        const token = peek$3(scanner);\n        if (brackets.expression) {\n            // If were inside expression, we should consume all content in it\n            if (isBracket$2(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote$1(token) || isOperator$1(token) || isWhiteSpace$2(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket$2(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume$2(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable$1(scanner)) {\n            const { pos } = scanner;\n            if (!consume$2(scanner, isClassNameOperator) || !consume$2(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable$1(scanner) && consume$2(scanner, isElementName$1)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume$2(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable$1(scanner)) {\n            const token = next(scanner);\n            if (isBracket$2(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket$2(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket$2(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket$2(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator$1(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote$1(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace$2(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator$1(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral$2(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral$2(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName$1(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator$1(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket$2(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket$2(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket$2(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket$2(token, 'group', true);\n}\nfunction createLiteral$1(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator$1(token, 'child');\n}\nfunction isSiblingOperator$1(token) {\n    return isOperator$1(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator$1(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator$1(token, 'close');\n}\n\nvar Chars$3;\n(function (Chars) {\n    /** `{` character */\n    Chars[Chars[\"CurlyBracketOpen\"] = 123] = \"CurlyBracketOpen\";\n    /** `}` character */\n    Chars[Chars[\"CurlyBracketClose\"] = 125] = \"CurlyBracketClose\";\n    /** `\\\\` character */\n    Chars[Chars[\"Escape\"] = 92] = \"Escape\";\n    /** `=` character */\n    Chars[Chars[\"Equals\"] = 61] = \"Equals\";\n    /** `[` character */\n    Chars[Chars[\"SquareBracketOpen\"] = 91] = \"SquareBracketOpen\";\n    /** `]` character */\n    Chars[Chars[\"SquareBracketClose\"] = 93] = \"SquareBracketClose\";\n    /** `*` character */\n    Chars[Chars[\"Asterisk\"] = 42] = \"Asterisk\";\n    /** `#` character */\n    Chars[Chars[\"Hash\"] = 35] = \"Hash\";\n    /** `$` character */\n    Chars[Chars[\"Dollar\"] = 36] = \"Dollar\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `.` character */\n    Chars[Chars[\"Dot\"] = 46] = \"Dot\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `!` character */\n    Chars[Chars[\"Excl\"] = 33] = \"Excl\";\n    /** `@` character */\n    Chars[Chars[\"At\"] = 64] = \"At\";\n    /** `_` character */\n    Chars[Chars[\"Underscore\"] = 95] = \"Underscore\";\n    /** `(` character */\n    Chars[Chars[\"RoundBracketOpen\"] = 40] = \"RoundBracketOpen\";\n    /** `)` character */\n    Chars[Chars[\"RoundBracketClose\"] = 41] = \"RoundBracketClose\";\n    /** `+` character */\n    Chars[Chars[\"Sibling\"] = 43] = \"Sibling\";\n    /** `>` character */\n    Chars[Chars[\"Child\"] = 62] = \"Child\";\n    /** `^` character */\n    Chars[Chars[\"Climb\"] = 94] = \"Climb\";\n    /** `'` character */\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    /** `\"\"` character */\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n})(Chars$3 || (Chars$3 = {}));\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(Chars$3.Escape)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize$1(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken$1(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken$1(scanner, ctx) {\n    return field$2(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater(scanner)\n        || whiteSpace$1(scanner)\n        || literal$2(scanner, ctx)\n        || operator$1(scanner)\n        || quote(scanner)\n        || bracket$1(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$2(scanner, ctx) {\n    const start = scanner.pos;\n    const expressionStart = ctx.expression;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === Chars$3.Slash && !ctx.quote && !ctx.expression && !ctx.attribute) {\n            // Special case for `/` character between numbers in class names\n            const prev = scanner.string.charCodeAt(scanner.pos - 1);\n            const next = scanner.string.charCodeAt(scanner.pos + 1);\n            if (isNumber$1(prev) && isNumber$1(next)) {\n                value += scanner.string[scanner.pos++];\n                continue;\n            }\n        }\n        if (ch === ctx.quote || ch === Chars$3.Dollar || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (expressionStart) {\n            // Consume nested expressions, e.g. span{{foo}}\n            if (ch === Chars$3.CurlyBracketOpen) {\n                ctx.expression++;\n            }\n            else if (ch === Chars$3.CurlyBracketClose) {\n                if (ctx.expression > expressionStart) {\n                    ctx.expression--;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else if (!ctx.quote) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$2(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$2(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === Chars$3.SingleQuote,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket$1(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket$2(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator$1(scanner) {\n    const op = operatorType$1(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$3.Asterisk)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber$1)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$3.Dollar) && scanner.eat(Chars$3.Hash)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(Chars$3.Dollar)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(Chars$3.At)) {\n            // Consume numbering modifiers\n            while (scanner.eat(Chars$3.Climb)) {\n                parent++;\n            }\n            reverse = scanner.eat(Chars$3.Dash);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber$1)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field$2(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(Chars$3.Dollar) && scanner.eat(Chars$3.CurlyBracketOpen)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // Its a field\n            index = Number(scanner.current());\n            name = scanner.eat(Chars$3.Colon) ? consumePlaceholder$2(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // Its a variable\n            name = consumePlaceholder$2(scanner);\n        }\n        if (scanner.eat(Chars$3.CurlyBracketClose)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then theres no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$2(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(Chars$3.CurlyBracketOpen)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(Chars$3.CurlyBracketClose)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and its allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType$1(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === Chars$3.Asterisk && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns its type\n */\nfunction bracketType(ch) {\n    if (ch === Chars$3.RoundBracketOpen || ch === Chars$3.RoundBracketClose) {\n        return 'group';\n    }\n    if (ch === Chars$3.SquareBracketOpen || ch === Chars$3.SquareBracketClose) {\n        return 'attribute';\n    }\n    if (ch === Chars$3.CurlyBracketOpen || ch === Chars$3.CurlyBracketClose) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns its type\n */\nfunction operatorType$1(ch) {\n    return (ch === Chars$3.Child && 'child')\n        || (ch === Chars$3.Sibling && 'sibling')\n        || (ch === Chars$3.Climb && 'climb')\n        || (ch === Chars$3.Dot && 'class')\n        || (ch === Chars$3.Hash && 'id')\n        || (ch === Chars$3.Slash && 'close')\n        || (ch === Chars$3.Equals && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket$2(ch) {\n    return ch === Chars$3.CurlyBracketOpen\n        || ch === Chars$3.SquareBracketOpen\n        || ch === Chars$3.RoundBracketOpen;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName(ch) {\n    return isAlphaNumericWord(ch)\n        || isUmlaut(ch)\n        || ch === Chars$3.Dash\n        || ch === Chars$3.Colon\n        || ch === Chars$3.Excl;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // Its a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // Its a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify$1(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last$1(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // Its an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last$1(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if its reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue$1(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField$1)) {\n        // XXX its unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote$1(tokens[0])) {\n            // Its a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last$1(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket$2(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket$2(last$1(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue$1(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType,\n        multiple: node.multiple\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify$1(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue$1(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField$1(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesnt support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify$1(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField$1(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last$1(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last$1(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        if (!node.attributes) {\n            node.attributes = [];\n        }\n        node.attributes.push({ name: 'href', value: [href], valueType: 'doubleQuote' });\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize$1(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nvar OperatorType;\n(function (OperatorType) {\n    OperatorType[\"Sibling\"] = \"+\";\n    OperatorType[\"Important\"] = \"!\";\n    OperatorType[\"ArgumentDelimiter\"] = \",\";\n    OperatorType[\"ValueDelimiter\"] = \"-\";\n    OperatorType[\"PropertyDelimiter\"] = \":\";\n})(OperatorType || (OperatorType = {}));\n\nvar Chars$2;\n(function (Chars) {\n    /** `#` character */\n    Chars[Chars[\"Hash\"] = 35] = \"Hash\";\n    /** `$` character */\n    Chars[Chars[\"Dollar\"] = 36] = \"Dollar\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `.` character */\n    Chars[Chars[\"Dot\"] = 46] = \"Dot\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `,` character */\n    Chars[Chars[\"Comma\"] = 44] = \"Comma\";\n    /** `!` character */\n    Chars[Chars[\"Excl\"] = 33] = \"Excl\";\n    /** `@` character */\n    Chars[Chars[\"At\"] = 64] = \"At\";\n    /** `%` character */\n    Chars[Chars[\"Percent\"] = 37] = \"Percent\";\n    /** `_` character */\n    Chars[Chars[\"Underscore\"] = 95] = \"Underscore\";\n    /** `(` character */\n    Chars[Chars[\"RoundBracketOpen\"] = 40] = \"RoundBracketOpen\";\n    /** `)` character */\n    Chars[Chars[\"RoundBracketClose\"] = 41] = \"RoundBracketClose\";\n    /** `{` character */\n    Chars[Chars[\"CurlyBracketOpen\"] = 123] = \"CurlyBracketOpen\";\n    /** `}` character */\n    Chars[Chars[\"CurlyBracketClose\"] = 125] = \"CurlyBracketClose\";\n    /** `+` character */\n    Chars[Chars[\"Sibling\"] = 43] = \"Sibling\";\n    /** `'` character */\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    /** `\"` character */\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    /** `t` character */\n    Chars[Chars[\"Transparent\"] = 116] = \"Transparent\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n})(Chars$2 || (Chars$2 = {}));\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field$1(scanner)\n        || customProperty(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, short);\n}\nfunction field$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Dollar) && scanner.eat(Chars$2.CurlyBracketOpen)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // Its a field\n            index = Number(scanner.current());\n            name = scanner.eat(Chars$2.Colon) ? consumePlaceholder$1(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // Its a variable\n            name = consumePlaceholder$1(scanner);\n        }\n        if (scanner.eat(Chars$2.CurlyBracketClose)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then theres no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$1(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(Chars$2.CurlyBracketOpen)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(Chars$2.CurlyBracketClose)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between short and full notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while full notation also supports numbers and dashes\n */\nfunction literal$1(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral$1);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral$1 : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(Chars$2.Dot);\n        scanner.eatWhile(isLiteral$1);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(Chars$2.Percent) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote$2(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === Chars$2.SingleQuote ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc    #aabbccc\n    // #0      #000000\n    // #fff.5  rgba(255, 255, 255, 0.5)\n    // #t      transparent\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Hash)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(Chars$2.Transparent)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Dot)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber$1)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes custom CSS property: --foo-bar\n */\nfunction customProperty(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Dash) && scanner.eat(Chars$2.Dash)) {\n        scanner.start = start;\n        scanner.eatWhile(isKeyword);\n        return {\n            type: 'CustomProperty',\n            value: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket$1(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === Chars$2.RoundBracketOpen,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(Chars$2.Dash);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber$1);\n    const prevPos = stream.pos;\n    if (stream.eat(Chars$2.Dot)) {\n        // Its perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber$1);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === Chars$2.At || code === Chars$2.Dollar;\n}\n/**\n * If given character is an operator, returns its type\n */\nfunction operatorType(ch) {\n    return (ch === Chars$2.Sibling && OperatorType.Sibling)\n        || (ch === Chars$2.Excl && OperatorType.Important)\n        || (ch === Chars$2.Comma && OperatorType.ArgumentDelimiter)\n        || (ch === Chars$2.Colon && OperatorType.PropertyDelimiter)\n        || (ch === Chars$2.Dash && OperatorType.ValueDelimiter)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber$1(code) || isAlpha$1(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === Chars$2.Dash;\n}\nfunction isBracket$1(code) {\n    return code === Chars$2.RoundBracketOpen || code === Chars$2.RoundBracketClose;\n}\nfunction isLiteral$1(code) {\n    return isAlphaWord(code) || code === Chars$2.Percent || code === Chars$2.Slash;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$2(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$1(scanner, test) {\n    if (test(peek$2(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek$2(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume$1(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek$2(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume$1(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume$1(scanner, isWhiteSpace$1);\n    }\n    while (readable(scanner)) {\n        if (consume$1(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume$1(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek$2(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace$1(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume$1(scanner, isOpenBracket$1)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume$1(scanner, isCloseBracket$1)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume$1(scanner, isWhiteSpace$1) && !consume$1(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket$1(token) {\n    return isBracket(token, true);\n}\nfunction isCloseBracket$1(token) {\n    return isBracket(token, false);\n}\nfunction isWhiteSpace$1(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, OperatorType.Sibling);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, OperatorType.ArgumentDelimiter);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, OperatorType.Important);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field'\n        || token.type === 'CustomProperty';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, OperatorType.PropertyDelimiter)\n        || isOperator(token, OperatorType.ValueDelimiter);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse$2(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk$1(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parseAbbreviation(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nconst expressionStart = '{';\nconst expressionEnd = '}';\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines$1(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? expressionStart : expressionEnd;\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines$1(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"-\", \"\", \"\", \"\", \" \", \"\", \" \", \"\", \"\", \"\"],\n\t\"words\": [\"\", \" \", \"\", \"\", \"\", \" \", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \" \", \"\", \"\",\"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\",\"\", \"\", \"\", \"lorem\", \"ipsum\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\",  \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"ms\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"pao\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"dems\", \"oficinista\", \"excepcin\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"curum\", \"dignsimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedicin\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"len\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"squito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asuncin\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentacin\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindo\", \"pcima\",\n\t\t\"voluble\", \"dbito\", \"sinti\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mnima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaa\", \"enigma\",\n\t\t\"total\", \"deletreo\", \"dcima\", \"cbala\", \"fotografa\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnfico\", \"distincin\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abada\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almcigo\", \"vos\", \"pan\",\n\t\t\"represin\", \"nmeros\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrn\", \"explcito\",\n\t\t\"paloma\", \"sndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propsito\",\n\t\t\"fantasa\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasnt modified: its not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\nvar TemplateChars;\n(function (TemplateChars) {\n    /** `[` character */\n    TemplateChars[TemplateChars[\"Start\"] = 91] = \"Start\";\n    /** `]` character */\n    TemplateChars[TemplateChars[\"End\"] = 93] = \"End\";\n    /* `_` character */\n    TemplateChars[TemplateChars[\"Underscore\"] = 95] = \"Underscore\";\n    /* `-` character */\n    TemplateChars[TemplateChars[\"Dash\"] = 45] = \"Dash\";\n})(TemplateChars || (TemplateChars = {}));\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek$1(scanner) === TemplateChars.Start) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek$1(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek$1(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === TemplateChars.Start) {\n                    stack++;\n                }\n                else if (code === TemplateChars.End) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek$1(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === TemplateChars.Underscore\n        || code === TemplateChars.Dash;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nconst reservedKeywords = new Set([\n    'for', 'while', 'of', 'async', 'await', 'const', 'let', 'var', 'continue',\n    'break', 'debugger', 'do', 'export', 'import', 'in', 'instanceof', 'new', 'return',\n    'switch', 'this', 'throw', 'try', 'catch', 'typeof', 'void', 'with', 'yield'\n]);\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat$1(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attributes content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const attributes = config.options['markup.attributes'];\n        const valuePrefix = config.options['markup.valuePrefix'];\n        let { name, value } = attr;\n        let lQuote = attrQuote(attr, config, true);\n        let rQuote = attrQuote(attr, config);\n        if (attributes) {\n            name = getMultiValue(name, attributes, attr.multiple) || name;\n        }\n        name = attrName(name, config);\n        const prefix = valuePrefix\n            ? getMultiValue(attr.name, valuePrefix, attr.multiple)\n            : null;\n        if (prefix && (value === null || value === void 0 ? void 0 : value.length) === 1 && typeof value[0] === 'string') {\n            // Add given prefix in object notation\n            const val = value[0];\n            value = [isPropKey(val) ? `${prefix}.${val}` : `${prefix}['${val}']`];\n            if (config.options['jsx.enabled']) {\n                lQuote = expressionStart;\n                rQuote = expressionEnd;\n            }\n        }\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and its a boolean value, check for\n            // `compactBoolean` option: if its disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat$1(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if its followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat$1(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getMultiValue(key, data, multiple) {\n    return (multiple && data[`${key}*`]) || data[key];\n}\nfunction isPropKey(name) {\n    return !reservedKeywords.has(name) && /^[a-zA-Z_$][\\w_$]*$/.test(name);\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        const parseOpt = Object.assign({}, config);\n        if (config.options['jsx.enabled']) {\n            parseOpt.jsx = true;\n        }\n        if (config.options['markup.href']) {\n            parseOpt.href = true;\n        }\n        abbr = parseAbbreviation(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk$1(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nvar CSSSnippetType;\n(function (CSSSnippetType) {\n    CSSSnippetType[\"Raw\"] = \"Raw\";\n    CSSSnippetType[\"Property\"] = \"Property\";\n})(CSSSnippetType || (CSSSnippetType = {}));\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: CSSSnippetType.Property,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: CSSSnippetType.Raw, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$2(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === CSSSnippetType.Property;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n *  first characters of both `str1` and `str2` *must* match\n *  `str1` length larger than `str2` length is allowed only when `unmatched` is true\n *  ideal match is when `str1` equals to `str2` (score: 1)\n *  next best match is `str2` starts with `str1` (score: 1  percent of matched characters)\n *  other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, its max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nconst CSSAbbreviationScope = {\n    /** Include all possible snippets in match */\n    Global: '@@global',\n    /** Include raw snippets only (e.g. no properties) in abbreviation match */\n    Section: '@@section',\n    /** Include properties only in abbreviation match */\n    Property: '@@property',\n    /** Resolve abbreviation in context of CSS property value */\n    Value: '@@value',\n};\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === CSSAbbreviationScope.Section) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // Its a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // Its a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal' || token.type === 'CustomProperty') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$2(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === CSSSnippetType.Property && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                if (snippet.type === CSSSnippetType.Property) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if theres multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasnt directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasnt found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === CSSAbbreviationScope.Value || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === CSSAbbreviationScope.Section) {\n            return snippets.filter(s => s.type === CSSSnippetType.Raw);\n        }\n        if (config.context.name === CSSAbbreviationScope.Property) {\n            return snippets.filter(s => s.type === CSSSnippetType.Property);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:refresh\": \"meta[http-equiv=refresh content='${1:5}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"script:module\": \"script[type=module src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bg:n\": \"background: none\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:${1:#fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|contents|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"g\": \"gap\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions$1 = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions$1\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true,\n            'markup.attributes': {\n                'class': 'className',\n                'class*': 'styleName',\n                'for': 'htmlFor'\n            },\n            'markup.valuePrefix': {\n                'class*': 'styles'\n            }\n        }\n    },\n    vue: {\n        options: {\n            'markup.attributes': {\n                'class*': ':class',\n            }\n        }\n    },\n    svelte: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * Peeks character code an current scanner location without advancing it\n */\nfunction peek(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek(scanner))\n        : match === peek(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\nvar Chars$1;\n(function (Chars) {\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    Chars[Chars[\"Escape\"] = 92] = \"Escape\";\n})(Chars$1 || (Chars$1 = {}));\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === Chars$1.SingleQuote || c === Chars$1.DoubleQuote;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek(scanner) !== Chars$1.Escape) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nvar Brackets;\n(function (Brackets) {\n    Brackets[Brackets[\"SquareL\"] = 91] = \"SquareL\";\n    Brackets[Brackets[\"SquareR\"] = 93] = \"SquareR\";\n    Brackets[Brackets[\"RoundL\"] = 40] = \"RoundL\";\n    Brackets[Brackets[\"RoundR\"] = 41] = \"RoundR\";\n    Brackets[Brackets[\"CurlyL\"] = 123] = \"CurlyL\";\n    Brackets[Brackets[\"CurlyR\"] = 125] = \"CurlyR\";\n})(Brackets || (Brackets = {}));\nconst bracePairs = {\n    [Brackets.SquareL]: Brackets.SquareR,\n    [Brackets.RoundL]: Brackets.RoundR,\n    [Brackets.CurlyL]: Brackets.CurlyR,\n};\n\nvar Chars;\n(function (Chars) {\n    Chars[Chars[\"Tab\"] = 9] = \"Tab\";\n    Chars[Chars[\"Space\"] = 32] = \"Space\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `=` character */\n    Chars[Chars[\"Equals\"] = 61] = \"Equals\";\n    /** `<` character */\n    Chars[Chars[\"AngleLeft\"] = 60] = \"AngleLeft\";\n    /** `>` character */\n    Chars[Chars[\"AngleRight\"] = 62] = \"AngleRight\";\n})(Chars || (Chars = {}));\n/**\n * Check if given readers current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, Chars.AngleRight)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, Chars.Slash); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, Chars.Slash)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, Chars.AngleLeft);\n                break;\n            }\n            else if (consume(scanner, Chars.AngleLeft)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, Chars.Equals)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === Chars.Colon || ch === Chars.Dash || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === Chars.Space || ch === Chars.Tab;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== Chars.Equals && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === Brackets.CurlyL || ch === Brackets.RoundL || ch === Brackets.SquareL;\n}\nfunction isCloseBracket(ch) {\n    return ch === Brackets.CurlyR || ch === Brackets.RoundR || ch === Brackets.SquareR;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editors line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation$1(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek(scanner);\n        if (stack.includes(Brackets.CurlyR)) {\n            if (ch === Brackets.CurlyR) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== Brackets.CurlyL) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(Brackets.SquareR) || stack.includes(Brackets.CurlyR)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: its nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, Brackets.SquareR, Brackets.SquareL) || consumePair(scanner, Brackets.CurlyR, Brackets.CurlyL)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === Brackets.RoundL || (syntax === 'markup' && (ch === Brackets.SquareL || ch === Brackets.CurlyL));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === Brackets.RoundR || (syntax === 'markup' && (ch === Brackets.SquareR || ch === Brackets.CurlyR));\n}\n\nfunction expandAbbreviation$1(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse$1(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse(abbr, config), config);\n}\n\nconst cssData = {\n    \"properties\": [\"additive-symbols\", \"align-content\", \"align-items\", \"justify-items\", \"justify-self\", \"justify-items\", \"align-self\", \"all\", \"alt\", \"animation\", \"animation-delay\", \"animation-direction\", \"animation-duration\", \"animation-fill-mode\", \"animation-iteration-count\", \"animation-name\", \"animation-play-state\", \"animation-timing-function\", \"backface-visibility\", \"background\", \"background-attachment\", \"background-blend-mode\", \"background-clip\", \"background-color\", \"background-image\", \"background-origin\", \"background-position\", \"background-position-x\", \"background-position-y\", \"background-repeat\", \"background-size\", \"behavior\", \"block-size\", \"border\", \"border-block-end\", \"border-block-start\", \"border-block-end-color\", \"border-block-start-color\", \"border-block-end-style\", \"border-block-start-style\", \"border-block-end-width\", \"border-block-start-width\", \"border-bottom\", \"border-bottom-color\", \"border-bottom-left-radius\", \"border-bottom-right-radius\", \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\", \"border-color\", \"border-image\", \"border-image-outset\", \"border-image-repeat\", \"border-image-slice\", \"border-image-source\", \"border-image-width\", \"border-inline-end\", \"border-inline-start\", \"border-inline-end-color\", \"border-inline-start-color\", \"border-inline-end-style\", \"border-inline-start-style\", \"border-inline-end-width\", \"border-inline-start-width\", \"border-left\", \"border-left-color\", \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\", \"border-right-color\", \"border-right-style\", \"border-right-width\", \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\", \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\", \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\", \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\", \"caption-side\", \"caret-color\", \"clear\", \"clip\", \"clip-path\", \"clip-rule\", \"color\", \"color-interpolation-filters\", \"column-count\", \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\", \"column-rule-style\", \"column-rule-width\", \"columns\", \"column-span\", \"column-width\", \"contain\", \"content\", \"counter-increment\", \"counter-reset\", \"cursor\", \"direction\", \"display\", \"empty-cells\", \"enable-background\", \"fallback\", \"fill\", \"fill-opacity\", \"fill-rule\", \"filter\", \"flex\", \"flex-basis\", \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\", \"float\", \"flood-color\", \"flood-opacity\", \"font\", \"font-family\", \"font-feature-settings\", \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\", \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\", \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\", \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\", \"font-weight\", \"glyph-orientation-horizontal\", \"glyph-orientation-vertical\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\", \"grid-auto-rows\", \"grid-column\", \"grid-column-end\", \"grid-column-gap\", \"grid-column-start\", \"grid-gap\", \"grid-row\", \"grid-row-end\", \"grid-row-gap\", \"grid-row-start\", \"grid-template\", \"grid-template-areas\", \"grid-template-columns\", \"grid-template-rows\", \"height\", \"hyphens\", \"image-orientation\", \"image-rendering\", \"ime-mode\", \"inline-size\", \"isolation\", \"justify-content\", \"kerning\", \"left\", \"letter-spacing\", \"lighting-color\", \"line-break\", \"line-height\", \"list-style\", \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\", \"margin-block-end\", \"margin-block-start\", \"margin-bottom\", \"margin-inline-end\", \"margin-inline-start\", \"margin-left\", \"margin-right\", \"margin-top\", \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"mask-type\", \"max-block-size\", \"max-height\", \"max-inline-size\", \"max-width\", \"min-block-size\", \"min-height\", \"min-inline-size\", \"min-width\", \"mix-blend-mode\", \"motion\", \"motion-offset\", \"motion-path\", \"motion-rotation\", \"-moz-animation\", \"-moz-animation-delay\", \"-moz-animation-direction\", \"-moz-animation-duration\", \"-moz-animation-iteration-count\", \"-moz-animation-name\", \"-moz-animation-play-state\", \"-moz-animation-timing-function\", \"-moz-appearance\", \"-moz-backface-visibility\", \"-moz-background-clip\", \"-moz-background-inline-policy\", \"-moz-background-origin\", \"-moz-border-bottom-colors\", \"-moz-border-image\", \"-moz-border-left-colors\", \"-moz-border-right-colors\", \"-moz-border-top-colors\", \"-moz-box-align\", \"-moz-box-direction\", \"-moz-box-flex\", \"-moz-box-flexgroup\", \"-moz-box-ordinal-group\", \"-moz-box-orient\", \"-moz-box-pack\", \"-moz-box-sizing\", \"-moz-column-count\", \"-moz-column-gap\", \"-moz-column-rule\", \"-moz-column-rule-color\", \"-moz-column-rule-style\", \"-moz-column-rule-width\", \"-moz-columns\", \"-moz-column-width\", \"-moz-font-feature-settings\", \"-moz-hyphens\", \"-moz-perspective\", \"-moz-perspective-origin\", \"-moz-text-align-last\", \"-moz-text-decoration-color\", \"-moz-text-decoration-line\", \"-moz-text-decoration-style\", \"-moz-text-size-adjust\", \"-moz-transform\", \"-moz-transform-origin\", \"-moz-transition\", \"-moz-transition-delay\", \"-moz-transition-duration\", \"-moz-transition-property\", \"-moz-transition-timing-function\", \"-moz-user-focus\", \"-moz-user-select\", \"-ms-accelerator\", \"-ms-behavior\", \"-ms-block-progression\", \"-ms-content-zoom-chaining\", \"-ms-content-zooming\", \"-ms-content-zoom-limit\", \"-ms-content-zoom-limit-max\", \"-ms-content-zoom-limit-min\", \"-ms-content-zoom-snap\", \"-ms-content-zoom-snap-points\", \"-ms-content-zoom-snap-type\", \"-ms-filter\", \"-ms-flex\", \"-ms-flex-align\", \"-ms-flex-direction\", \"-ms-flex-flow\", \"-ms-flex-item-align\", \"-ms-flex-line-pack\", \"-ms-flex-order\", \"-ms-flex-pack\", \"-ms-flex-wrap\", \"-ms-flow-from\", \"-ms-flow-into\", \"-ms-grid-column\", \"-ms-grid-column-align\", \"-ms-grid-columns\", \"-ms-grid-column-span\", \"-ms-grid-layer\", \"-ms-grid-row\", \"-ms-grid-row-align\", \"-ms-grid-rows\", \"-ms-grid-row-span\", \"-ms-high-contrast-adjust\", \"-ms-hyphenate-limit-chars\", \"-ms-hyphenate-limit-lines\", \"-ms-hyphenate-limit-zone\", \"-ms-hyphens\", \"-ms-ime-mode\", \"-ms-interpolation-mode\", \"-ms-layout-grid\", \"-ms-layout-grid-char\", \"-ms-layout-grid-line\", \"-ms-layout-grid-mode\", \"-ms-layout-grid-type\", \"-ms-line-break\", \"-ms-overflow-style\", \"-ms-perspective\", \"-ms-perspective-origin\", \"-ms-perspective-origin-x\", \"-ms-perspective-origin-y\", \"-ms-progress-appearance\", \"-ms-scrollbar-3dlight-color\", \"-ms-scrollbar-arrow-color\", \"-ms-scrollbar-base-color\", \"-ms-scrollbar-darkshadow-color\", \"-ms-scrollbar-face-color\", \"-ms-scrollbar-highlight-color\", \"-ms-scrollbar-shadow-color\", \"-ms-scrollbar-track-color\", \"-ms-scroll-chaining\", \"-ms-scroll-limit\", \"-ms-scroll-limit-x-max\", \"-ms-scroll-limit-x-min\", \"-ms-scroll-limit-y-max\", \"-ms-scroll-limit-y-min\", \"-ms-scroll-rails\", \"-ms-scroll-snap-points-x\", \"-ms-scroll-snap-points-y\", \"-ms-scroll-snap-type\", \"-ms-scroll-snap-x\", \"-ms-scroll-snap-y\", \"-ms-scroll-translation\", \"-ms-text-align-last\", \"-ms-text-autospace\", \"-ms-text-combine-horizontal\", \"-ms-text-justify\", \"-ms-text-kashida-space\", \"-ms-text-overflow\", \"-ms-text-size-adjust\", \"-ms-text-underline-position\", \"-ms-touch-action\", \"-ms-touch-select\", \"-ms-transform\", \"-ms-transform-origin\", \"-ms-transform-origin-x\", \"-ms-transform-origin-y\", \"-ms-transform-origin-z\", \"-ms-user-select\", \"-ms-word-break\", \"-ms-word-wrap\", \"-ms-wrap-flow\", \"-ms-wrap-margin\", \"-ms-wrap-through\", \"-ms-writing-mode\", \"-ms-zoom\", \"-ms-zoom-animation\", \"nav-down\", \"nav-index\", \"nav-left\", \"nav-right\", \"nav-up\", \"negative\", \"-o-animation\", \"-o-animation-delay\", \"-o-animation-direction\", \"-o-animation-duration\", \"-o-animation-fill-mode\", \"-o-animation-iteration-count\", \"-o-animation-name\", \"-o-animation-play-state\", \"-o-animation-timing-function\", \"object-fit\", \"object-position\", \"-o-border-image\", \"-o-object-fit\", \"-o-object-position\", \"opacity\", \"order\", \"orphans\", \"-o-table-baseline\", \"-o-tab-size\", \"-o-text-overflow\", \"-o-transform\", \"-o-transform-origin\", \"-o-transition\", \"-o-transition-delay\", \"-o-transition-duration\", \"-o-transition-property\", \"-o-transition-timing-function\", \"offset-block-end\", \"offset-block-start\", \"offset-inline-end\", \"offset-inline-start\", \"outline\", \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\", \"overflow\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\", \"pad\", \"padding\", \"padding-bottom\", \"padding-block-end\", \"padding-block-start\", \"padding-inline-end\", \"padding-inline-start\", \"padding-left\", \"padding-right\", \"padding-top\", \"page-break-after\", \"page-break-before\", \"page-break-inside\", \"paint-order\", \"perspective\", \"perspective-origin\", \"pointer-events\", \"position\", \"prefix\", \"quotes\", \"range\", \"resize\", \"right\", \"ruby-align\", \"ruby-overhang\", \"ruby-position\", \"ruby-span\", \"scrollbar-3dlight-color\", \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-darkshadow-color\", \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\", \"scrollbar-track-color\", \"scroll-behavior\", \"scroll-snap-coordinate\", \"scroll-snap-destination\", \"scroll-snap-points-x\", \"scroll-snap-points-y\", \"scroll-snap-type\", \"shape-image-threshold\", \"shape-margin\", \"shape-outside\", \"shape-rendering\", \"size\", \"src\", \"stop-color\", \"stop-opacity\", \"stroke\", \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\", \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"suffix\", \"system\", \"symbols\", \"table-layout\", \"tab-size\", \"text-align\", \"text-align-last\", \"text-anchor\", \"text-decoration\", \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-style\", \"text-indent\", \"text-justify\", \"text-orientation\", \"text-overflow\", \"text-rendering\", \"text-shadow\", \"text-transform\", \"text-underline-position\", \"top\", \"touch-action\", \"transform\", \"transform-origin\", \"transform-style\", \"transition\", \"transition-delay\", \"transition-duration\", \"transition-property\", \"transition-timing-function\", \"unicode-bidi\", \"unicode-range\", \"user-select\", \"vertical-align\", \"visibility\", \"-webkit-animation\", \"-webkit-animation-delay\", \"-webkit-animation-direction\", \"-webkit-animation-duration\", \"-webkit-animation-fill-mode\", \"-webkit-animation-iteration-count\", \"-webkit-animation-name\", \"-webkit-animation-play-state\", \"-webkit-animation-timing-function\", \"-webkit-appearance\", \"-webkit-backdrop-filter\", \"-webkit-backface-visibility\", \"-webkit-background-clip\", \"-webkit-background-composite\", \"-webkit-background-origin\", \"-webkit-border-image\", \"-webkit-box-align\", \"-webkit-box-direction\", \"-webkit-box-flex\", \"-webkit-box-flex-group\", \"-webkit-box-ordinal-group\", \"-webkit-box-orient\", \"-webkit-box-pack\", \"-webkit-box-reflect\", \"-webkit-box-sizing\", \"-webkit-break-after\", \"-webkit-break-before\", \"-webkit-break-inside\", \"-webkit-column-break-after\", \"-webkit-column-break-before\", \"-webkit-column-break-inside\", \"-webkit-column-count\", \"-webkit-column-gap\", \"-webkit-column-rule\", \"-webkit-column-rule-color\", \"-webkit-column-rule-style\", \"-webkit-column-rule-width\", \"-webkit-columns\", \"-webkit-column-span\", \"-webkit-column-width\", \"-webkit-filter\", \"-webkit-flow-from\", \"-webkit-flow-into\", \"-webkit-font-feature-settings\", \"-webkit-hyphens\", \"-webkit-line-break\", \"-webkit-margin-bottom-collapse\", \"-webkit-margin-collapse\", \"-webkit-margin-start\", \"-webkit-margin-top-collapse\", \"-webkit-mask-clip\", \"-webkit-mask-image\", \"-webkit-mask-origin\", \"-webkit-mask-repeat\", \"-webkit-mask-size\", \"-webkit-nbsp-mode\", \"-webkit-overflow-scrolling\", \"-webkit-padding-start\", \"-webkit-perspective\", \"-webkit-perspective-origin\", \"-webkit-region-fragment\", \"-webkit-tap-highlight-color\", \"-webkit-text-fill-color\", \"-webkit-text-size-adjust\", \"-webkit-text-stroke\", \"-webkit-text-stroke-color\", \"-webkit-text-stroke-width\", \"-webkit-touch-callout\", \"-webkit-transform\", \"-webkit-transform-origin\", \"-webkit-transform-origin-x\", \"-webkit-transform-origin-y\", \"-webkit-transform-origin-z\", \"-webkit-transform-style\", \"-webkit-transition\", \"-webkit-transition-delay\", \"-webkit-transition-duration\", \"-webkit-transition-property\", \"-webkit-transition-timing-function\", \"-webkit-user-drag\", \"-webkit-user-modify\", \"-webkit-user-select\", \"white-space\", \"widows\", \"width\", \"will-change\", \"word-break\", \"word-spacing\", \"word-wrap\", \"writing-mode\", \"z-index\", \"zoom\"]\n};\nconst htmlData = {\n    \"tags\": [\n        \"body\", \"head\", \"html\",\n        \"address\", \"blockquote\", \"dd\", \"div\", \"section\", \"article\", \"aside\", \"header\", \"footer\", \"nav\", \"menu\", \"dl\", \"dt\", \"fieldset\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"iframe\", \"noframes\", \"object\", \"ol\", \"p\", \"ul\", \"applet\", \"center\", \"dir\", \"hr\", \"pre\",\n        \"a\", \"abbr\", \"acronym\", \"area\", \"b\", \"base\", \"basefont\", \"bdo\", \"big\", \"br\", \"button\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\", \"del\", \"dfn\", \"em\", \"font\", \"i\", \"img\", \"input\", \"ins\", \"isindex\", \"kbd\", \"label\", \"legend\", \"li\", \"link\", \"map\", \"meta\", \"noscript\", \"optgroup\", \"option\", \"param\", \"q\", \"s\", \"samp\", \"script\", \"select\", \"small\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"sup\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"tt\", \"u\", \"var\",\n        \"canvas\", \"main\", \"figure\", \"plaintext\", \"figcaption\", \"hgroup\", \"details\", \"summary\"\n    ]\n};\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst snippetKeyCache = new Map();\nlet markupSnippetKeys;\nconst stylesheetCustomSnippetsKeyCache = new Map();\nconst htmlAbbreviationStartRegex = /^[a-z,A-Z,!,(,[,#,\\.\\{]/;\n// take off { for jsx because it interferes with the language\nconst jsxAbbreviationStartRegex = /^[a-z,A-Z,!,(,[,#,\\.]/;\nconst cssAbbreviationRegex = /^-?[a-z,A-Z,!,@,#]/;\nconst htmlAbbreviationRegex = /[a-z,A-Z\\.]/;\nconst commonlyUsedTags = [...htmlData.tags, 'lorem'];\nconst bemFilterSuffix = 'bem';\nconst filterDelimitor = '|';\nconst trimFilterSuffix = 't';\nconst commentFilterSuffix = 'c';\nconst maxFilters = 3;\n/**\n * Returns all applicable emmet expansions for abbreviation at given position in a CompletionList\n * @param model TextModel in which completions are requested\n * @param position Position in the document at which completions are requested\n * @param syntax Emmet supported language\n * @param emmetConfig Emmet Configurations as derived from VS Code\n */\nfunction doComplete(monaco, model, position, syntax, emmetConfig) {\n    var _a;\n    const isStyleSheetRes = isStyleSheet(syntax);\n    // Fetch markupSnippets so that we can provide possible abbreviation completions\n    // For example, when text at position is `a`, completions should return `a:blank`, `a:link`, `acr` etc.\n    if (!isStyleSheetRes) {\n        if (!snippetKeyCache.has(syntax)) {\n            const registry = Object.assign(Object.assign({}, getDefaultSnippets(syntax)), customSnippetsRegistry[syntax]);\n            snippetKeyCache.set(syntax, Object.keys(registry));\n        }\n        markupSnippetKeys = (_a = snippetKeyCache.get(syntax)) !== null && _a !== void 0 ? _a : [];\n    }\n    const extractOptions = {\n        lookAhead: !isStyleSheetRes,\n        type: getSyntaxType(syntax),\n    };\n    const extractedValue = extractAbbreviation(monaco, model, position, extractOptions);\n    if (!extractedValue)\n        return;\n    const { abbreviationRange, abbreviation, currentLineTillPosition, filter } = extractedValue;\n    const currentWord = getCurrentWord(currentLineTillPosition);\n    // Don't attempt to expand open tags\n    if (currentWord === abbreviation && currentLineTillPosition.endsWith(`<${abbreviation}`) && !isStyleSheetRes) {\n        return;\n    }\n    const expandOptions = getExpandOptions(syntax, filter);\n    let expandedText = '';\n    let expandedAbbr;\n    let completionItems = [];\n    // Create completion item after expanding given abbreviation\n    // if abbreviation is valid and expanded value is not noise\n    const createExpandedAbbr = (syntax, abbr) => {\n        if (!isAbbreviationValid(syntax, abbreviation))\n            return;\n        try {\n            expandedText = expandAbbreviation$1(abbr, expandOptions);\n            // manually patch https://github.com/microsoft/vscode/issues/120245 for now\n            if (isStyleSheetRes && '!important'.startsWith(abbr)) {\n                expandedText = '!important';\n            }\n        }\n        catch (e) { }\n        if (!expandedText || isExpandedTextNoise(syntax, abbr, expandedText, expandOptions.options)) {\n            return;\n        }\n        expandedAbbr = {\n            kind: monaco.languages.CompletionItemKind.Property,\n            label: abbreviation + (filter ? '|' + filter.replace(',', '|') : ''),\n            documentation: replaceTabStopsWithCursors(expandedText),\n            detail: 'Emmet abbreviation',\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            range: abbreviationRange,\n            insertText: escapeNonTabStopDollar(addFinalTabStop(expandedText)),\n        };\n        completionItems = [expandedAbbr];\n    };\n    createExpandedAbbr(syntax, abbreviation);\n    if (isStyleSheetRes) {\n        // When abbr is longer than usual emmet snippets and matches better with existing css property, then no emmet\n        if (abbreviation.length > 4 && cssData.properties.some((x) => x.startsWith(abbreviation))) {\n            return { suggestions: [], incomplete: true };\n        }\n        if (expandedAbbr && expandedText.length) {\n            expandedAbbr.range = abbreviationRange;\n            expandedAbbr.insertText = escapeNonTabStopDollar(addFinalTabStop(expandedText));\n            expandedAbbr.documentation = replaceTabStopsWithCursors(expandedText);\n            expandedAbbr.label = removeTabStops(expandedText);\n            expandedAbbr.filterText = abbreviation;\n            // Custom snippets should show up in completions if abbreviation is a prefix\n            const stylesheetCustomSnippetsKeys = stylesheetCustomSnippetsKeyCache.has(syntax)\n                ? stylesheetCustomSnippetsKeyCache.get(syntax)\n                : stylesheetCustomSnippetsKeyCache.get('css');\n            completionItems = makeSnippetSuggestion(monaco, stylesheetCustomSnippetsKeys !== null && stylesheetCustomSnippetsKeys !== void 0 ? stylesheetCustomSnippetsKeys : [], abbreviation, abbreviation, abbreviationRange, expandOptions, 'Emmet Custom Snippet', false);\n            if (!completionItems.find((x) => x.insertText === (expandedAbbr === null || expandedAbbr === void 0 ? void 0 : expandedAbbr.insertText))) {\n                // Fix for https://github.com/Microsoft/vscode/issues/28933#issuecomment-309236902\n                // When user types in propertyname, emmet uses it to match with snippet names, resulting in width -> widows or font-family -> font: family\n                // Filter out those cases here.\n                const abbrRegex = new RegExp('.*' +\n                    abbreviation\n                        .split('')\n                        .map((x) => (x === '$' || x === '+' ? '\\\\' + x : x))\n                        .join('.*') +\n                    '.*', 'i');\n                if (/\\d/.test(abbreviation) || abbrRegex.test(expandedAbbr.label)) {\n                    completionItems.push(expandedAbbr);\n                }\n            }\n        }\n    }\n    else {\n        let tagToFindMoreSuggestionsFor = abbreviation;\n        const newTagMatches = abbreviation.match(/(>|\\+)([\\w:-]+)$/);\n        if (newTagMatches && newTagMatches.length === 3) {\n            tagToFindMoreSuggestionsFor = newTagMatches[2];\n        }\n        if (syntax !== 'xml') {\n            const commonlyUsedTagSuggestions = makeSnippetSuggestion(monaco, commonlyUsedTags, tagToFindMoreSuggestionsFor, abbreviation, abbreviationRange, expandOptions, 'Emmet Abbreviation');\n            completionItems = completionItems.concat(commonlyUsedTagSuggestions);\n        }\n        if (emmetConfig.showAbbreviationSuggestions === true) {\n            const abbreviationSuggestions = makeSnippetSuggestion(monaco, markupSnippetKeys.filter((x) => !commonlyUsedTags.includes(x)), tagToFindMoreSuggestionsFor, abbreviation, abbreviationRange, expandOptions, 'Emmet Abbreviation');\n            // Workaround for the main expanded abbr not appearing before the snippet suggestions\n            if (expandedAbbr && abbreviationSuggestions.length > 0 && tagToFindMoreSuggestionsFor !== abbreviation) {\n                expandedAbbr.sortText = '0' + expandedAbbr.label;\n                abbreviationSuggestions.forEach((item) => {\n                    // Workaround for snippet suggestions items getting filtered out as the complete abbr does not start with snippetKey\n                    item.filterText = abbreviation;\n                    // Workaround for the main expanded abbr not appearing before the snippet suggestions\n                    item.sortText = '9' + abbreviation;\n                });\n            }\n            completionItems = completionItems.concat(abbreviationSuggestions);\n        }\n        // https://github.com/microsoft/vscode/issues/66680\n        if (syntax === 'html' &&\n            completionItems.length >= 2 &&\n            abbreviation.includes(':') &&\n            (expandedAbbr === null || expandedAbbr === void 0 ? void 0 : expandedAbbr.insertText) === `<${abbreviation}>\\${0}</${abbreviation}>`) {\n            completionItems = completionItems.filter((item) => item.label !== abbreviation);\n        }\n    }\n    if (emmetConfig.showSuggestionsAsSnippets === true) {\n        completionItems.forEach((x) => (x.kind = monaco.languages.CompletionItemKind.Snippet));\n    }\n    return completionItems.length ? { suggestions: completionItems, incomplete: true } : undefined;\n}\n/**\n * Create & return snippets for snippet keys that start with given prefix\n */\nfunction makeSnippetSuggestion(monaco, snippetKeys, prefix, abbreviation, abbreviationRange, expandOptions, snippetDetail, skipFullMatch = true) {\n    if (!prefix || !snippetKeys) {\n        return [];\n    }\n    const snippetCompletions = [];\n    snippetKeys.forEach((snippetKey) => {\n        if (!snippetKey.startsWith(prefix.toLowerCase()) || (skipFullMatch && snippetKey === prefix.toLowerCase())) {\n            return;\n        }\n        const currentAbbr = abbreviation + snippetKey.substr(prefix.length);\n        let expandedAbbr;\n        try {\n            expandedAbbr = expandAbbreviation$1(currentAbbr, expandOptions);\n        }\n        catch (e) { }\n        if (!expandedAbbr) {\n            return;\n        }\n        const item = {\n            kind: monaco.languages.CompletionItemKind.Property,\n            label: prefix + snippetKey.substr(prefix.length),\n            documentation: replaceTabStopsWithCursors(expandedAbbr),\n            detail: snippetDetail,\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            range: abbreviationRange,\n            insertText: escapeNonTabStopDollar(addFinalTabStop(expandedAbbr)),\n        };\n        snippetCompletions.push(item);\n    });\n    return snippetCompletions;\n}\nfunction getCurrentWord(currentLineTillPosition) {\n    if (currentLineTillPosition) {\n        const matches = currentLineTillPosition.match(/[\\w,:,-,\\.]*$/);\n        if (matches) {\n            return matches[0];\n        }\n    }\n}\nfunction replaceTabStopsWithCursors(expandedWord) {\n    return expandedWord.replace(/([^\\\\])\\$\\{\\d+\\}/g, '$1|').replace(/\\$\\{\\d+:([^\\}]+)\\}/g, '$1');\n}\nfunction removeTabStops(expandedWord) {\n    return expandedWord.replace(/([^\\\\])\\$\\{\\d+\\}/g, '$1').replace(/\\$\\{\\d+:([^\\}]+)\\}/g, '$1');\n}\nfunction escapeNonTabStopDollar(text) {\n    return text ? text.replace(/([^\\\\])(\\$)([^\\{])/g, '$1\\\\$2$3') : text;\n}\nfunction addFinalTabStop(text) {\n    if (!text || !text.trim()) {\n        return text;\n    }\n    let maxTabStop = -1;\n    let maxTabStopRanges = [];\n    let foundLastStop = false;\n    let replaceWithLastStop = false;\n    let i = 0;\n    const n = text.length;\n    try {\n        while (i < n && !foundLastStop) {\n            // Look for ${\n            if (text[i++] != '$' || text[i++] != '{') {\n                continue;\n            }\n            // Find tabstop\n            let numberStart = -1;\n            let numberEnd = -1;\n            while (i < n && /\\d/.test(text[i])) {\n                numberStart = numberStart < 0 ? i : numberStart;\n                numberEnd = i + 1;\n                i++;\n            }\n            // If ${ was not followed by a number and either } or :, then its not a tabstop\n            if (numberStart === -1 || numberEnd === -1 || i >= n || (text[i] != '}' && text[i] != ':')) {\n                continue;\n            }\n            // If ${0} was found, then break\n            const currentTabStop = text.substring(numberStart, numberEnd);\n            foundLastStop = currentTabStop === '0';\n            if (foundLastStop) {\n                break;\n            }\n            let foundPlaceholder = false;\n            if (text[i++] == ':') {\n                // TODO: Nested placeholders may break here\n                while (i < n) {\n                    if (text[i] == '}') {\n                        foundPlaceholder = true;\n                        break;\n                    }\n                    i++;\n                }\n            }\n            // Decide to replace currentTabStop with ${0} only if its the max among all tabstops and is not a placeholder\n            if (Number(currentTabStop) > Number(maxTabStop)) {\n                maxTabStop = Number(currentTabStop);\n                maxTabStopRanges = [{ numberStart, numberEnd }];\n                replaceWithLastStop = !foundPlaceholder;\n            }\n            else if (Number(currentTabStop) === maxTabStop) {\n                maxTabStopRanges.push({ numberStart, numberEnd });\n            }\n        }\n    }\n    catch (e) { }\n    if (replaceWithLastStop && !foundLastStop) {\n        for (let i = 0; i < maxTabStopRanges.length; i++) {\n            const rangeStart = maxTabStopRanges[i].numberStart;\n            const rangeEnd = maxTabStopRanges[i].numberEnd;\n            text = text.substr(0, rangeStart) + '0' + text.substr(rangeEnd);\n        }\n    }\n    return text;\n}\nlet customSnippetsRegistry = {};\nconst emmetSnippetField = (index, placeholder) => `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n/** Returns whether or not syntax is a supported stylesheet syntax, like CSS */\nfunction isStyleSheet(syntax) {\n    return syntax === 'css';\n}\n/** Returns the syntax type, either markup (e.g. for HTML) or stylesheet (e.g. for CSS) */\nfunction getSyntaxType(syntax) {\n    return isStyleSheet(syntax) ? 'stylesheet' : 'markup';\n}\n/** Returns the default syntax (html or css) to use for the snippets registry */\nfunction getDefaultSyntax(syntax) {\n    return isStyleSheet(syntax) ? 'css' : 'html';\n}\n/** Returns the default snippets that Emmet suggests */\nfunction getDefaultSnippets(syntax) {\n    const syntaxType = getSyntaxType(syntax);\n    const emptyUserConfig = { type: syntaxType, syntax };\n    const resolvedConfig = resolveConfig(emptyUserConfig);\n    // https://github.com/microsoft/vscode/issues/97632\n    // don't return markup (HTML) snippets for XML\n    return syntax === 'xml' ? {} : resolvedConfig.snippets;\n}\nfunction getFilters(text, pos) {\n    let filter;\n    for (let i = 0; i < maxFilters; i++) {\n        if (text.endsWith(`${filterDelimitor}${bemFilterSuffix}`, pos)) {\n            pos -= bemFilterSuffix.length + 1;\n            filter = filter ? bemFilterSuffix + ',' + filter : bemFilterSuffix;\n        }\n        else if (text.endsWith(`${filterDelimitor}${commentFilterSuffix}`, pos)) {\n            pos -= commentFilterSuffix.length + 1;\n            filter = filter ? commentFilterSuffix + ',' + filter : commentFilterSuffix;\n        }\n        else if (text.endsWith(`${filterDelimitor}${trimFilterSuffix}`, pos)) {\n            pos -= trimFilterSuffix.length + 1;\n            filter = filter ? trimFilterSuffix + ',' + filter : trimFilterSuffix;\n        }\n        else {\n            break;\n        }\n    }\n    return {\n        pos: pos,\n        filter: filter,\n    };\n}\n/**\n * Extracts abbreviation from the given position in the given document\n * @param model The TextModel from which abbreviation needs to be extracted\n * @param position The Position in the given document from where abbreviation needs to be extracted\n * @param options The options to pass to the @emmetio/extract-abbreviation module\n */\nfunction extractAbbreviation(monaco, model, position, options) {\n    const currentLine = model.getLineContent(position.lineNumber);\n    const currentLineTillPosition = currentLine.substr(0, position.column - 1);\n    const { pos, filter } = getFilters(currentLineTillPosition, position.column - 1);\n    const lengthOccupiedByFilter = filter ? filter.length + 1 : 0;\n    const result = extractAbbreviation$1(currentLine, pos, options);\n    if (!result)\n        return;\n    const rangeToReplace = new monaco.Range(position.lineNumber, result.location + 1, position.lineNumber, result.location + result.abbreviation.length + lengthOccupiedByFilter + 1);\n    return {\n        abbreviationRange: rangeToReplace,\n        abbreviation: result.abbreviation,\n        currentLineTillPosition,\n        filter,\n    };\n}\n/**\n * Returns a boolean denoting validity of given abbreviation in the context of given syntax\n * Not needed once https://github.com/emmetio/atom-plugin/issues/22 is fixed\n * @param syntax string\n * @param abbreviation string\n */\nfunction isAbbreviationValid(syntax, abbreviation) {\n    if (!abbreviation) {\n        return false;\n    }\n    if (isStyleSheet(syntax)) {\n        if (abbreviation.includes('#')) {\n            if (abbreviation.startsWith('#')) {\n                const hexColorRegex = /^#[\\d,a-f,A-F]{1,6}$/;\n                return hexColorRegex.test(abbreviation);\n            }\n            else if (commonlyUsedTags.includes(abbreviation.substring(0, abbreviation.indexOf('#')))) {\n                return false;\n            }\n        }\n        return cssAbbreviationRegex.test(abbreviation);\n    }\n    if (abbreviation.startsWith('!')) {\n        return !/[^!]/.test(abbreviation);\n    }\n    // Its common for users to type (sometextinsidebrackets), this should not be treated as an abbreviation\n    // Grouping in abbreviation is valid only if it's inside a text node or preceeded/succeeded with one of the symbols for nesting, sibling, repeater or climb up\n    // Also, cases such as `span[onclick=\"alert();\"]` are valid\n    if ((/\\(/.test(abbreviation) || /\\)/.test(abbreviation)) &&\n        !/\\{[^\\}\\{]*[\\(\\)]+[^\\}\\{]*\\}(?:[>\\+\\*\\^]|$)/.test(abbreviation) &&\n        !/\\(.*\\)[>\\+\\*\\^]/.test(abbreviation) &&\n        !/\\[[^\\[\\]\\(\\)]+=\".*\"\\]/.test(abbreviation) &&\n        !/[>\\+\\*\\^]\\(.*\\)/.test(abbreviation)) {\n        return false;\n    }\n    if (syntax === 'jsx') {\n        return jsxAbbreviationStartRegex.test(abbreviation) && htmlAbbreviationRegex.test(abbreviation);\n    }\n    return htmlAbbreviationStartRegex.test(abbreviation) && htmlAbbreviationRegex.test(abbreviation);\n}\nfunction isExpandedTextNoise(syntax, abbreviation, expandedText, options) {\n    var _a, _b;\n    // Unresolved css abbreviations get expanded to a blank property value\n    // Eg: abc -> abc: ; or abc:d -> abc: d; which is noise if it gets suggested for every word typed\n    if (isStyleSheet(syntax) && options) {\n        const between = (_a = options['stylesheet.between']) !== null && _a !== void 0 ? _a : ': ';\n        const after = (_b = options['stylesheet.after']) !== null && _b !== void 0 ? _b : ';';\n        // Remove overlapping between `abbreviation` and `between`, if any\n        let endPrefixIndex = abbreviation.indexOf(between[0], Math.max(abbreviation.length - between.length, 0));\n        endPrefixIndex = endPrefixIndex >= 0 ? endPrefixIndex : abbreviation.length;\n        const abbr = abbreviation.substring(0, endPrefixIndex);\n        return (expandedText === `${abbr}${between}\\${0}${after}` ||\n            expandedText.replace(/\\s/g, '') === abbreviation.replace(/\\s/g, '') + after);\n    }\n    // we don't want common html tags suggested for xml\n    if (syntax === 'xml' && commonlyUsedTags.some((tag) => tag.startsWith(abbreviation.toLowerCase()))) {\n        return true;\n    }\n    if (commonlyUsedTags.includes(abbreviation.toLowerCase()) || markupSnippetKeys.includes(abbreviation)) {\n        return false;\n    }\n    // Custom tags can have - or :\n    if (/[-,:]/.test(abbreviation) && !/--|::/.test(abbreviation) && !abbreviation.endsWith(':')) {\n        return false;\n    }\n    // Its common for users to type some text and end it with period, this should not be treated as an abbreviation\n    // Else it becomes noise.\n    // When user just types '.', return the expansion\n    // Otherwise emmet loses change to participate later\n    // For example in `.foo`. See https://github.com/Microsoft/vscode/issues/66013\n    if (abbreviation === '.') {\n        return false;\n    }\n    const dotMatches = abbreviation.match(/^([a-z,A-Z,\\d]*)\\.$/);\n    if (dotMatches) {\n        // Valid html tags such as `div.`\n        if (dotMatches[1] && htmlData.tags.includes(dotMatches[1])) {\n            return false;\n        }\n        return true;\n    }\n    // Fix for https://github.com/microsoft/vscode/issues/89746\n    // PascalCase tags are common in jsx code, which should not be treated as noise.\n    // Eg: MyAwesomComponent -> <MyAwesomComponent></MyAwesomComponent>\n    if (syntax === 'jsx' && /^([A-Z][A-Za-z0-9]*)+$/.test(abbreviation)) {\n        return false;\n    }\n    // Unresolved html abbreviations get expanded as if it were a tag\n    // Eg: abc -> <abc></abc> which is noise if it gets suggested for every word typed\n    return expandedText.toLowerCase() === `<${abbreviation.toLowerCase()}>\\${1}</${abbreviation.toLowerCase()}>`;\n}\n/**\n * Returns options to be used by emmet\n */\nfunction getExpandOptions(syntax, filter) {\n    var _a;\n    const filters = filter ? filter.split(',').map((x) => x.trim()) : [];\n    const bemEnabled = filters.includes('bem');\n    const commentEnabled = filters.includes('c');\n    const combinedOptions = {\n        'output.formatSkip': ['html'],\n        'output.formatForce': ['body'],\n        'output.field': emmetSnippetField,\n        'output.inlineBreak': 0,\n        'output.compactBoolean': false,\n        'output.reverseAttributes': false,\n        'markup.href': true,\n        'comment.enabled': commentEnabled,\n        'comment.trigger': ['id', 'class'],\n        'comment.before': '',\n        'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n        'bem.enabled': bemEnabled,\n        'bem.element': '__',\n        'bem.modifier': '_',\n        'jsx.enabled': syntax === 'jsx',\n        'stylesheet.shortHex': true,\n        'stylesheet.between': syntax === 'stylus' ? ' ' : ': ',\n        'stylesheet.after': syntax === 'sass' || syntax === 'stylus' ? '' : ';',\n        'stylesheet.intUnit': 'px',\n        'stylesheet.floatUnit': 'em',\n        'stylesheet.unitAliases': {\n            e: 'em',\n            p: '%',\n            x: 'ex',\n            r: 'rem',\n        },\n        'stylesheet.fuzzySearchMinScore': 0.3,\n        'output.format': true,\n        'output.selfClosingStyle': 'html',\n    };\n    const type = getSyntaxType(syntax);\n    const baseSyntax = getDefaultSyntax(syntax);\n    const snippets = type === 'stylesheet'\n        ? (_a = customSnippetsRegistry[syntax]) !== null && _a !== void 0 ? _a : customSnippetsRegistry[baseSyntax]\n        : customSnippetsRegistry[syntax];\n    return {\n        type,\n        options: combinedOptions,\n        variables: {},\n        snippets: snippets,\n        syntax,\n        // context: null,\n        text: undefined,\n        maxRepeat: 1000,\n        // cache: null\n    };\n}\n/**\n * Assigns snippets from one snippet file under emmet.extensionsPath to\n * customSnippetsRegistry, snippetKeyCache, and stylesheetCustomSnippetsKeyCache\n */\nfunction registerCustomSnippets(syntax, customSnippets) {\n    const baseSyntax = getDefaultSyntax(syntax);\n    if (baseSyntax !== syntax && customSnippetsRegistry[baseSyntax]) {\n        customSnippets = Object.assign({}, customSnippetsRegistry[baseSyntax], customSnippets);\n    }\n    if (isStyleSheet(syntax)) {\n        const prevSnippetKeys = stylesheetCustomSnippetsKeyCache.get(syntax);\n        const mergedSnippetKeys = Object.assign([], prevSnippetKeys, Object.keys(customSnippets));\n        stylesheetCustomSnippetsKeyCache.set(syntax, mergedSnippetKeys);\n    }\n    const prevSnippetsRegistry = customSnippetsRegistry[syntax];\n    const mergedSnippets = Object.assign({}, prevSnippetsRegistry, customSnippets);\n    customSnippetsRegistry[syntax] = mergedSnippets;\n}\n/**\n * Expands given abbreviation using given options\n * @param abbreviation string or parsed abbreviation\n * @param config options used by the @emmetio/expand-abbreviation module to expand given abbreviation\n */\nfunction expandAbbreviation(abbreviation, config) {\n    let expandedText;\n    const resolvedConfig = resolveConfig(config);\n    if (config.type === 'stylesheet') {\n        if (typeof abbreviation === 'string') {\n            expandedText = expandAbbreviation$1(abbreviation, resolvedConfig);\n        }\n        else {\n            expandedText = css(abbreviation, resolvedConfig);\n        }\n    }\n    else {\n        if (typeof abbreviation === 'string') {\n            expandedText = expandAbbreviation$1(abbreviation, resolvedConfig);\n        }\n        else {\n            expandedText = stringify(abbreviation, resolvedConfig);\n        }\n    }\n    return escapeNonTabStopDollar(addFinalTabStop(expandedText));\n}\n\nfunction isValidEmmetToken(tokens, index, syntax, language) {\n    const currentTokenType = tokens[index].type;\n    if (syntax === 'html') {\n        // prevent emmet triggered within attributes\n        return ((currentTokenType === '' && (index === 0 || tokens[index - 1].type === 'delimiter.html')) ||\n            // #7 compatible with https://github.com/NeekSandhu/monaco-textmate\n            tokens[0].type === 'text.html.basic');\n    }\n    if (syntax === 'css') {\n        if (currentTokenType === '')\n            return true;\n        // less / scss allow nesting\n        return currentTokenType === 'tag.' + language;\n    }\n    if (syntax === 'jsx') {\n        // type must be `identifier` and not at start\n        return (!!index &&\n            ['identifier.js', 'type.identifier.js', 'identifier.ts', 'type.identifier.ts'].includes(currentTokenType));\n    }\n    return false;\n}\nconst tokenEnvCache = new WeakMap();\nfunction getTokenizationEnv(model) {\n    if (tokenEnvCache.has(model))\n        return tokenEnvCache.get(model);\n    let _tokenization = \n    // monaco-editor < 0.34.0\n    model._tokenization ||\n        // monaco-editor 0.34.0\n        model.tokenization._tokenization;\n    // monaco-editor <= 0.34.0\n    let _tokenizationStateStore = _tokenization === null || _tokenization === void 0 ? void 0 : _tokenization._tokenizationStateStore;\n    // monaco-editor >= 0.35.0\n    if (!_tokenization || !_tokenizationStateStore) {\n        const _t = model.tokenization;\n        if (_t.grammarTokens) {\n            // monaco-editor >= 0.37.0\n            _tokenization = _t.grammarTokens._defaultBackgroundTokenizer;\n            _tokenizationStateStore = _tokenization._tokenizerWithStateStore;\n        }\n        else {\n            // monaco-editor >= 0.35.0 && < 0.37.0, source code was minified\n            Object.values(_t).some((val) => (_tokenization = val.tokenizeViewport && val));\n            Object.values(_tokenization).some((val) => (_tokenizationStateStore = val.tokenizationSupport && val));\n        }\n    }\n    const _tokenizationSupport = \n    // monaco-editor >= 0.32.0\n    _tokenizationStateStore.tokenizationSupport ||\n        // monaco-editor < 0.32.0\n        _tokenization._tokenizationSupport;\n    const env = {\n        _stateStore: _tokenizationStateStore,\n        _support: _tokenizationSupport,\n    };\n    tokenEnvCache.set(model, env);\n    return env;\n}\n// vscode did a complex node analysis, we just use monaco's built-in tokenizer\n// to achieve almost the same effect\nfunction isValidLocationForEmmetAbbreviation(model, position, syntax, language) {\n    var _a;\n    const { column, lineNumber } = position;\n    // get current line's tokens\n    const { _stateStore, _support } = getTokenizationEnv(model);\n    // monaco-editor < 0.37.0 uses `getBeginState` while monaco-editor >= 0.37.0 uses `getStartState`\n    // note: lineNumber difference between two api\n    const state = ((_a = _stateStore.getBeginState) === null || _a === void 0 ? void 0 : _a.call(_stateStore, lineNumber - 1).clone()) || _stateStore.getStartState(lineNumber).clone();\n    const tokenizationResult = _support.tokenize(model.getLineContent(lineNumber), true, state, 0);\n    const tokens = tokenizationResult.tokens;\n    let valid = false;\n    // get token type at current column\n    for (let i = tokens.length - 1; i >= 0; i--) {\n        if (column - 1 > tokens[i].offset) {\n            valid = isValidEmmetToken(tokens, i, syntax, language);\n            break;\n        }\n    }\n    return valid;\n}\n\n// https://github.com/microsoft/vscode/blob/main/extensions/emmet/src/util.ts#L86\nconst LANGUAGE_MODES = {\n    html: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    jade: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    slim: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    haml: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    xml: ['.', '}', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    xsl: ['!', '.', '}', '*', '$', '/', ']', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    css: [':', '!', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    scss: [':', '!', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    sass: [':', '!', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    less: [':', '!', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    stylus: [':', '!', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    javascript: ['!', '.', '}', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    typescript: ['!', '.', '}', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n};\n// https://github.com/microsoft/vscode/blob/main/extensions/emmet/src/util.ts#L124\nconst MAPPED_MODES = {\n    handlebars: 'html',\n    php: 'html',\n    twig: 'html',\n};\nconst DEFAULT_CONFIG = {\n    showExpandedAbbreviation: 'always',\n    showAbbreviationSuggestions: true,\n    showSuggestionsAsSnippets: false,\n};\n/**\n * add completion provider\n * @param monaco monaco self\n * @param language added language\n * @param isMarkup is markup language\n * @param isLegalToken check whether given token is legal or not\n * @param getLegalEmmetSets get legal emmet substring from a string.\n */\nfunction registerProvider(monaco, languages, syntax) {\n    if (!monaco) {\n        console.error(\"emmet-monaco-es: 'monaco' should be either declared on window or passed as first parameter\");\n        return;\n    }\n    const providers = languages.map((language) => monaco.languages.registerCompletionItemProvider(language, {\n        triggerCharacters: LANGUAGE_MODES[MAPPED_MODES[language] || language],\n        provideCompletionItems: (model, position) => isValidLocationForEmmetAbbreviation(model, position, syntax, language)\n            ? doComplete(monaco, model, position, syntax, DEFAULT_CONFIG)\n            : undefined,\n    }));\n    return () => {\n        providers.forEach((provider) => provider.dispose());\n    };\n}\nfunction emmetHTML(monaco = window.monaco, languages = ['html']) {\n    return registerProvider(monaco, languages, 'html');\n}\nfunction emmetCSS(monaco = window.monaco, languages = ['css']) {\n    return registerProvider(monaco, languages, 'css');\n}\nfunction emmetJSX(monaco = window.monaco, languages = ['javascript']) {\n    return registerProvider(monaco, languages, 'jsx');\n}\n\nexport { emmetCSS, emmetHTML, emmetJSX, expandAbbreviation, registerCustomSnippets };\n"],"names":[],"version":3,"file":"index.ac9dc4ba.js.map","sourceRoot":"/__parcel_source_root/"}